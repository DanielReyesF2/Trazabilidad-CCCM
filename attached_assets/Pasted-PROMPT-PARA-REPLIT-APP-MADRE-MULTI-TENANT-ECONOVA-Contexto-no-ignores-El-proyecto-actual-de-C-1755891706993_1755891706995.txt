PROMPT PARA REPLIT — APP MADRE MULTI-TENANT (ECONOVA)
Contexto (no ignores)

El proyecto actual de CCCM ya funciona excelente. No rompas nada: conserva rutas, flujos y componentes existentes.

Queremos escalar a una app madre multi-tenant con tres clientes:

cccm (con datos reales existentes)

club-de-golf-avandaro (sin datos — no inventar)

rancho-avandaro (sin datos — no inventar)

Tech stack actual: Replit + (React/TS) + Supabase (o equivalente). Si el repo usa otra variante (Vite/Next/Express), adáptate al stack real sin reescribirlo todo.

Objetivo

Convertir la app en multi-tenant con:

Aislamiento total de datos por client_id (RLS).

Portal Admin EcoNova (vista global y selector de cliente).

Portal Cliente (/:clientSlug/...), cada cliente solo ve lo suyo.

Branding y módulos personalizables por cliente (feature flags/settings).

Script de “provisioning” para dar de alta nuevos tenants en minutos.

Requisitos Funcionales (must)

Rutas

Admin interno: /admin/*

Cliente: /:clientSlug/* (ej.: /cccm/dashboard, /club-de-golf-avandaro/dashboard)

Opcional futuro: subdominios por cliente (dejar hook preparado).

Auth / JWT

JWT con user_id, client_id (o null para admin global) y scopes (admin:global o portal:*).

Middleware: si la ruta es /:clientSlug, resolver client_id por slug y forzar ese client_id en server (el cliente no puede sobreescribirlo).

RLS

Activar Row Level Security en todas las tablas operativas y de archivos; políticas select/insert/update/delete restringidas por client_id.

Usuarios con admin:global pueden hacer bypass seguro para vistas agregadas.

Branding & Settings por cliente

Tabla de client con slug, name, logo_url, primary_color, accent_color, timezone.

client_settings (clave/valor) p.ej. unidades, idioma, umbrales, formatos de reporte.

client_feature_flags para activar módulos (p. ej., module.procurement, module.zero_waste_events, etc.).

Admin EcoNova

Home /admin: selector de cliente + tarjetas con métricas agregadas (solo de CCCM por ahora si no hay datos en otros).

Vista “Tenants” para listar/editar branding, settings y flags por cliente.

Portal Cliente

Mantener TODOS los flujos y dashboards tal y como funcionan en CCCM.

Al entrar con slug ≠ cccm, mostrar la UI vacía (sin datos) pero operativa (sin placeholders inventados).

Provisioning

Script único (p. ej. scripts/provision_tenant.ts) que:

Crea client (slug, nombre, branding default)

Crea roles base y relación client_user si se pasa listado de e-mails

Inicializa client_settings y client_feature_flags

Crea prefijos de storage y seeds de catálogos (opcional, pero sin datos de operación)

Tests

Tests de autorización que intenten cruzar tenants (deben fallar).

Test de RLS por tabla clave.

Test de UI: al cambiar clientSlug se aísla data y tema.

Cambios de Esquema (SQL)

Ajusta nombres a los de tu esquema real; si ya existen, no dupliques. Solo migra si falta algo.

-- Tabla de clientes
create table if not exists public.client (
  id uuid primary key default gen_random_uuid(),
  slug text unique not null,
  name text not null,
  logo_url text,
  primary_color text,
  accent_color text,
  timezone text default 'America/Mexico_City',
  segment text,
  is_active boolean default true,
  created_at timestamptz default now()
);

-- Relación usuario-cliente y roles
create table if not exists public.client_user (
  client_id uuid references public.client(id) on delete cascade,
  user_id uuid references auth.users(id) on delete cascade,
  role text check (role in ('owner','admin','editor','viewer')) not null,
  primary key (client_id, user_id)
);

-- Settings y Feature Flags
create table if not exists public.client_settings (
  client_id uuid references public.client(id) on delete cascade,
  key text not null,
  value jsonb not null,
  primary key (client_id, key)
);

create table if not exists public.client_feature_flags (
  client_id uuid references public.client(id) on delete cascade,
  feature text not null,
  enabled boolean not null default false,
  primary key (client_id, feature)
);

-- Asegurar client_id en TODAS las tablas operativas:
-- alter table public.events add column if not exists client_id uuid references public.client(id);
-- Repetir para cada tabla core...

RLS (ejemplo)
alter table public.events enable row level security;

create policy "tenant_select" on public.events
for select using (
  auth.jwt()->>'scopes' like '%admin:global%' OR client_id = (auth.jwt()->>'client_id')::uuid
);

create policy "tenant_modify" on public.events
for all using (
  auth.jwt()->>'scopes' like '%admin:global%' OR client_id = (auth.jwt()->>'client_id')::uuid
) with check (
  auth.jwt()->>'scopes' like '%admin:global%' OR client_id = (auth.jwt()->>'client_id')::uuid
);

Backend / Middleware

Crear un resolver de tenant:

Si ruta /:clientSlug/* → buscar client.slug y setear req.context.client_id

Si /admin/* → req.context.isAdmin = true

Sanitizar consultas: jamás confiar en client_id que venga del frontend.

Endpoints deben leer req.context.client_id o isAdmin y aplicar filtros.

Frontend

Estructura de rutas:

/admin (home global + selector de cliente)

/admin/tenants (CRUD básico de branding, settings, flags)

/:clientSlug/dashboard (usa componentes ya existentes de CCCM)

Tema dinámico: al cargar /:clientSlug/*, fetch de client y aplicar logo/colors.

Feature Flags: wrapper simple para ocultar/mostrar módulos por cliente.

Seed / Datos iniciales

Migrar tal cual los datos reales actuales de CCCM al modelo multi-tenant (agrega client_id de CCCM).

Crear dos clientes sin data:

club-de-golf-avandaro (name: “Club de Golf Avándaro”) → sin datos de operación

rancho-avandaro (name: “Rancho Avándaro”) → sin datos de operación

Script de Provisioning (CLI)

Archivo: scripts/provision_tenant.ts

Input: slug, name, emails[] (opcional), branding, features

Output: IDs creados y credenciales/invitaciones.

Idempotente: si el slug existe, no duplicar.

Observabilidad

Añadir audit_log(client_id, user_id, action, entity, before, after, ts) y registrar eventos clave (login, cambios de settings/flags).

Personalización por Cliente (sin “ifs” por todo el código)

client_settings y client_feature_flags centralizan diferencias.

Evita ramas if (slug === 'x'); usa config desde DB y componentes condicionales por flags.

Entregables (definición de done)

 Migraciones aplicadas sin romper CCCM.

 Rutas /admin/* y /:clientSlug/* funcionando.

 CCCM opera igual que antes (dashboards sin cambios de UX/función).

 Avándaro y Rancho Avándaro creados, visibles, sin datos.

 Tema dinámico por cliente cargando desde DB.

 RLS verificada con tests (cruce de tenants imposible).

 Script provision_tenant.ts corriendo con ejemplo.

 Docs cortas en docs/multi-tenant.md (provisioning, alta de cliente, flags).

Notas de seguridad

En JWT no expongas secretos ni settings sensibles.

Storage: prefijos por cliente (traces/{client_id}/...) y reglas atadas a JWT.

Variables de entorno (ejemplo)

NEXT_PUBLIC_SUPABASE_URL, SUPABASE_SERVICE_ROLE, JWT_SECRET, etc. (ajustar al stack real del repo).

No inventes datos para Avándaro ni Rancho Avándaro. Solo estructura, branding por default y módulos desactivados hasta que haya información real.

Ejecuta esto en una rama feat/multitenant-app-madre. Al terminar, entrega PR con checklist de arriba y demo:

/admin (selector + vista global)

/cccm/dashboard (operativo)

/club-de-golf-avandaro/dashboard (UI sin datos)

/rancho-avandaro/dashboard (UI sin datos)